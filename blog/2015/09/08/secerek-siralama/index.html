<!DOCTYPE html>
<html>
  <head>
    <!-- meta information -->
<meta charset="utf-8">
<meta name="description" 
      content="Ünlü sıralama algoritmalarından biri olan ve kabarcık sıralaması olarak da bilinen bubble sort aynı veri türleri aras..." >
<meta name="author" content="Abdullah Velioglu">

<!-- Enable responsiveness on mobile devices-->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

<!-- title -->
<title>SECEREK SIRALAMA(SELECTION SORT) &middot; Abdullah</title>

<!-- icons -->
<link rel="shortcut icon" href="/blog/public/images/favicon.ico" />

<!-- stylesheets -->
<link rel="stylesheet" href="/blog/public/css/responsive.gs.12col.css">
<link rel="stylesheet" href="/blog/public/css/animate.min.css">
<link rel="stylesheet" href="/blog/public/css/main.css">

<!-- Google fonts -->
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,400italic&subset=latin-ext">



<!-- feed links -->
<link rel="alternate" href="www.abdullahvelioglu.com/blog/feed.xml" type="application/rss+xml" title="">

  </head>
  <body>
    <div class="container azul">
      <header class="top row gutters">
        <div class="col span_2 center">
          <!-- TODO: add baseurl to the logo link -->
          <a href="http://www.abdullahvelioglu.com/blog" id="logo" title="Abdullah"
             style="background-image: url(/blog/public/images/logo.png);"></a>
        </div>
        <nav class="col span_10 top-navbar">
  
  <a href="/blog" title="Blog"
     >Blog</a>
  
  <a href="/blog/about" title="Hakkinda"
     >Hakkinda</a>
  
  <a href="/blog/category" title="Kategori"
     >Kategori</a>
  
</nav>

      </header>

      <article class="single row gutters">
  <time class="published" datetime="2015-09-08">08 September 2015</time>
  <h2>SECEREK SIRALAMA(SELECTION SORT)</h2>
  


  <p>Ünlü sıralama algoritmalarından biri olan ve kabarcık sıralaması olarak da bilinen bubble sort aynı veri türleri arasında bulunan elemanların içinde,en büyük sayısal değerli elemanı komşu elemanlarıyla kıyaslayarak listenin sonuna atarak sıralama yapan bir sıralama algoritmasıdır.
<br/><br/>
Selection Sort(seçerek sıralama) algoritmasının tersine en büyük elemanı hedefleyerek işleyişini surdurur.Tarama sırasında,şayet değer olarak komşu elemanından daha büyük ise o anda yerini değiştirir.Hatırlarsanız selection sort’te tarama işlemi sona kadar gider ve tarama işlemi bitiminde en küçük eleman ilk sıraya konurdu.Fakat bubble sort’te tarama sırasında yer değiştirme(Swap) operasyonu koşul sağlandığı anda gerçekleşir.Konumuzu örnekler ile pekiştirelim..<br/><br/></p>

<p>Örneğin ;
<br/><br/></p>

<p>23  11   9   44   10   sayılarından oluşan bir kümemiz olsun.Kabarcık algoritması şu şekilde işleyecektir.İlk olarak 23 sayısı 11 ile karşılaştırılır. 23  &gt; 11 olduğundan swap uygulanır ve yeni görünüm   11  23  9  44  10  olacaktır.<br/><br/>
Akabinde aynı işlemler devam eder. 23 &gt; 9 olduğundan bir yer değiştirme işlemi daha olur. 11  9  23  44  10. Devamında,  23 &lt; 44  olduğundan 23 sayısı olduğu yerde kalır ve elemanlarda yer değişikliği olmaz.<br/><br/>
 11  9  23  44  10. Daha sonra sıra 44 dedir. 44 &gt; 10 olduğundan tekrar değişiklik olacaktır ve ilk tarama bakım sonrasında elemanlarımızın görünüm değerleri şu şekilde olur.<br/><br/>
11  9  23  10  44.
 Görüldüğü üzere en büyük eleman listemizde en sona ulaşmış oldu !<br/>
Selection Sort’te ise en küçük eleman ilk süzgeçten sonra en başta konumlanıyordu.Tekrar belirtmekte fayda var ki iki algoritmanın işleyişi tamamen farklıdır.Sadece akılda kalması babında algoritmalar arasındaki benzerliklere veya farklılıklara değinecektir.Elemanlarımıza dönecek olursak son görünümleri  11  9  23  10  44 oldu.<br/><br/>
Algoritmanın çalışması gereği işlem tekrardan ilk elemana döner.Yani 11 ile işlem tekrar başlatılır.Aynı mantıkla 11 &gt; 9 olduğu için takas gerçekleşecektir. 9  11  23  10  44. Daha sonra 11 &lt; 23 durumunda değişiklik olmayacaktır.Aynı şekilde sıra 23’e gelir ki 23 &gt; 10 olduğu için tekrar transfer gerçekleşir.<br/><br/>
9  11  10  23  44.Bu süzgeçleme adımının son kısmında (23 &lt; 44) durumundan dolayı Swap gerçekleşmez.İşlem tekrar 9 dan itibaren tekrar başlayacaktır.Yukarıda anlatılan aynı mantıkla işlemler gerçekleşecek ve algoritmanın son durumunda görünüm tahmin edebileceğiniz gibi,
9  10  11  23  44  olacaktır.
<br/><br/>
Simdi bir başka örnek ile sadece adımları inceleyelim ve konumuzu iyice hazmedelim.<br/></p>

<pre>
34  26  10  1  -4

1.  Adım --- 26  34  10  1  -4    
2.  Adım --- 26  10  34  1  -4
3.  Adım --- 26  10  1  34  -4
4.  Adım --- 26  10  1  -4   34 // Bu adımdan sonra en büyük eleman sona ulaşır.
5.  Adım --- 10  26  1  -4   34  //   Tekrar başa dönüldü ve 10-26 yer değişir.
6.  Adım --- 10  1  26  -4   34
7.  Adım --- 10  1  -4   26  34
8.  Adım --- 10  1  -4   26  34 // Değişme olmayacaktır çünkü 26 < 34
9.  Adım --- 1  10  -4   26  34  // Başa dönüldü ve  10-1 swap operasyonu
10. Adım --- 1  -4   10  26  34
11. Adım       Değişme Yok   ( 10 < 26)
12. Adım       Değişme Yok     (26 < 34)
13. Adım --- -4  1  10  26  34   // nihayetinde Sıralanmış olacaktır.
</pre>

<p>Fakat makinemiz bunu fark etmeyecektir ve listenin sonuna kadar bakmaya devam edecektir.<br/>
14-15 ve 16.Adımlarda da değişmeler olmayacağından elemanlarımızı bubble sort algoritması ile başarılı bir şekilde sıralamış oluruz.<br/>
Bubble sort algoritmasıda selection sort algoritması gibi daha karmaşık elemanlı dizilerde veya başka veri yapılarında kullanışlı değildir.<br/>
<p>Algoritmanın C dilindeki karşılığı aşağıdaki gibi verilebilir</p>
<pre>
  int i,j;
  int temp=0;
  int min=0,konum=0,flag=0;
  for(i=0;i<boyut-1,i++){
    min=dizi[i];
    flag=0;
    for(j=1;j<boyut-1;j++){
      if(min> dizi[j+1]){
        min=dizi[j+1];
        konum=j+1;
        flag=1;
      }
    }
    if(flag==1){
      temp=dizi[i];
      dizi[i]=dizi[konum];
      dizi[konum]=temp;
    }
  }
  return dizi;
}
</pre>
<br/>
<p>Algoritma ayrıca bağlı liste modeli ile aşağıdaki gibi verilebilir</p>
<pre>
node *selectionShort(node *kutu){
  int i=0,j=0,konum=0,flag=0,temp=0;
  node *iter=kutu;
  node *root=kutu;
  if(kutu==NULL)
  return NULL;
  else if(kutu-&gt;next==NULL)
  return kutu;
  else{
    int min=kutu-&gt;data;
    while(root-&gt;next!=NULL){
      while(iter-&gt;next!=NULL){
        if(min&gt;iter-&gt;next-&gt;data){
          min=iter-&gt;next-&gt;data;
          konum=i+1;
          flag=1;
        }
        iter=iter-&gt;next;
        i++;
      }
      if(flag==1){
        iter=kutu;
        for(int k=0;k<konum;k++){
        iter=iter->next;
        temp=iter-&gt;data;
        iter-&gt;data=root-&gt;data;
        root-&gt;data=temp;
      }
      root=root-&gt;next;
      j++;
      iter=root;
      min=iter-&gt;data;
      i=j;
      flag=0;
      }
    }
    return kutu;
  }
}
</pre></p>


  <p id="post-meta">Kategori <i class="fa fa-tag"></i>: <a href="http://www.abdullahvelioglu.com/blog/category/algorithm/">Algoritmalar</a></p>

</article>


      <footer>
        <p>
          Bu site <a rel="license" target="_blank" href="http://www.abdullahvelioglu.com/blog/about/">Abdullah Velioğlu</a> tarafından <a rel="license" target="_blank" href="https://jekyllrb.com/docs">Jekyll Dokümantasyonu </a> kullanılarak tasarlanmıştır. <br>Tamamen açık kaynak kodlu olan bu web sitesinin kaynak kodlarını <a rel="license" target="_blank" href="https://github.com/abdullahvelioglu/jekyllstaticblog">buraya </a> tıklayarak görebilirsiniz.
        </p>
      </footer>
    </div>

    <!-- scripts -->
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
    <script src="/blog/public/js/jquery.fitvids.js"></script>
    <script>
      $(document).ready(function(){
        $("article").fitVids();
      });
    </script>
  </body>
</html>

